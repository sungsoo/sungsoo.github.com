---
layout: post
title: YAML
date: 2022-05-24
categories: [computer science]
tags: [machine learning, graph mining]

---

### Article Source

* [YAML](https://ko.wikipedia.org/wiki/YAML)


---

# YAML

YAML은 XML, C, 파이썬, 펄, RFC2822에서 정의된 e-mail 양식에서 개념을 얻어 만들어진 '사람이 쉽게 읽을 수 있는' 데이터 직렬화 양식이다. 2001년에 클라크 에반스가 고안했고, Ingy dot Net 및 Oren Ben-Kiki와 함께 디자인했다.

YAML이라는 이름은 "YAML은 마크업 언어가 아니다 (YAML Ain't Markup Language)” 라는 재귀적인 이름에서 유래되었다. 원래 YAML의 뜻은 “또 다른 마크업 언어 (Yet Another Markup Language)”였으나, YAML의 핵심은 문서 마크업이 아닌 **데이터 중심**(YAML이 문서가 아닌 데이터용임을 강조하는 말)에 있다는 것을 보여주기 위해 이름을 바꾸었다. 오늘날 XML과 JSON이 데이터 직렬화에 주로 쓰이기 시작하면서, 많은 사람들이 YAML을 '가벼운 마크업 언어'로 사용하려 하고 있다.

## 요소

YAML은 모든 데이터를 리스트, 해쉬, 스칼라 데이터의 조합으로 적절히 표현할 수 있다는 믿음을 가지고 만들어졌다. 문법은 상대적으로 이해하기 쉽고, 가독성이 좋도록 디자인되었으며, 고급 컴퓨터 언어에 적합하다. 또한 들여쓰기 및 XML의 특수기호를 사용하기 때문에, XML과 거의 비슷하다.

* YAML 문자열은 UTF-8 또는 UTF-16과 같이 출력 가능한 유니코드 문자집합을 이용한다.
* 공백 문자를 이용한 들여쓰기로 구조체를 구분한다. 그러나 탭문자를 들여쓰기에 사용하지 않는다.
* 리스트 요소는 여러 줄에 쓸 때에는 하이픈(-)으로 시작하는 한 줄에 하나의 요소를 표현하며, 한 줄에 모아 쓸 때에는 대괄호([])를 이용하며 쉼표로 각 요소를 구분한다.
* 해쉬는 콜론 기호를 이용해서 키:값의 형태로 한 줄에 하나를 표현하거나, 한 줄에 모아 쓸 때에는 중괄호({})를 이용하며 쉼표로 각 요소를 구분한다.
* 간단한 값(스칼라 값)은 보통 아무 표시를 하지 않으나 따옴표("")나 작은 따옴표('')를 이용해 둘러쌀 수 있다.
* 따옴표 안에서 특수 문자는 C언어 스타일(역슬래쉬키와 함께쓰이는 제어문자 예. \n)로 표시한다.
* 블록 값은 보존(|) 또는 접기(>)의 선택 지시자로 나눈다.
* 하나의 스트림에 있는 여러 개의 문서는 하이픈 3개(---)로 나누며, 마침표 세개(...)로 스트림의 끝을 나타낸다.
* 반복되는 노드는 기본적으로 &를 통해 나타내며, * 문자 이후의 내용을 참조한다.
* 주석은 #으로 표시하며, 한 줄이 끝날 때까지 유효하다.
* 노드들은 타입과 느낌표로 시작해 URI 주소를 지시하는 태그를 통해 라벨이 붙는다.
* YAML 문서는 % 문자로 시작되는 몇 개의 지시자를 통해 특정 작업을 수행한다. YAML 1.1에서는 두 개의 지시자가 정의되어 있다.
	* %YAML 지시자는 주어진 문서의 YAML 버전을 나타내는 데 사용한다.
	* %TAG 지시자는 URI 주소를 나타내는 데 주로 사용하며, 이들 주소는 노드 타입 태그에 사용한다.

YAML은 공백과 스칼라 값을 가지고 있는 리스트 구분자를 위해 쉼표와 콜론이 필요하다. 미래의 표준화를 위해 YAML에서는 @, 엑센트 기호 ‘ 2개의 기호 문자를 예약해두고 있다.

## 예제
YAML에는 Perl, C, XML, HTML, 기타 프로그래밍 언어에서 유래한 기능이 있다. 또한 YAML은 JSON의 상위 집합이므로 YAML에서 JSON 파일을 사용할 수 있다.

YAML은 Python 스타일의 들여쓰기 방법으로 중첩을 표시한다. 탭 문자는 허용되지 않으므로, 공백을 대신 사용한다. 중괄호, 대괄호, 닫기 태그 또는 따옴표와 같은 통상적인 형식 기호는 없습니다. YAML 파일은 .yml 또는 .yaml이라는 확장자를 사용한다. 

YAML 파일은 맵 또는 목록 구조로 되어 있다.

맵 구조에서는 키-값 쌍을 연결할 수 있다. 각 키는 고유해야 하며 순서는 상관없습니다. Python 사전, 또는 Bash 스크립트의 변수 할당을 생각해 보자.

YAML의 맵은 먼저 해결해야 닫을 수 있고, 그런 다음 새 맵이 생성됩니다. 들여쓰기 수준을 높이거나 이전 맵을 해결하고 인근 맵을 시작함으로써 새 맵을 생성할 수 있다. 

목록의 값은 특정 순서로 나열되며, 목록 하나에 필요한 수의 항목을 포함할 수 있다. 목록 시퀀스는 대시(-) 및 공백으로 시작하며 들여쓰기로 상위 항목과 구분한다. 여기서 시퀀스는 Python 목록 또는 Bash나 Perl의 어레이에 해당한다. 목록을 맵에 포함할 수 있다. 

또한 YAML은 스칼라를 포함할 수 있는데, 스칼라란 문자열, 정수, 날짜, 숫자 또는 부울 등의 값으로 사용할 수 있는 임의의 데이터(유니코드로 인코딩됨)를 말한다.

YAML 파일을 생성할 때는 이러한 구문 규칙을 준수하고 파일이 유효한지 확인해야 한다. 린터(linter)는 파일의 구문을 검증하는 애플리케이션입니다. YAML 파일을 생성한 후 애플리케이션에 전달하기 전에 yamllint라는 커맨드로 유효성을 확인할 수 있다.



### 리스트

```
     --- # Favorite movies, block format
     - Casablanca
     - Spellbound
     - Notorious
     --- # Shopping list, inline format
     [Casablanca, Spellbound, Notorious]
```

### 해시

```
     --- # Block
     name: John Smith
     age: 33
     --- # Inline
     {name: John Smith, age: 33}
```

#### Block Literals

##### Newlines preserved
```
     --- |
       There was a young fellow of Warwick
       Who had reason for feeling euphoric
           For he could, by election
           Have triune erection
       Ionic, Corinthian, and Doric 11
```

##### Newlines folded
```
     --- >
       Wrapped text
       will be folded
       into a single
       paragraph

       Blank lines denote
       paragraph breaks
```

### 해시의 리스트
```
     - [name: John Smith, age: 33]
     - name: Mary Smith
       age: 2
```

### 리스트의 해시

```
     men: [John Smith, Bill Jones]
     women:
       - Mary Smith
       - Susan Williams
```

## 쿠버네티스용 YAML

쿠버네티스는 정의된 상태와 실제 상태를 기반으로 작동한다. 쿠버네티스 오브젝트는 클러스터의 상태를 나타내며, 사용자가 바라는 워크로드 상태를 쿠버네티스에 알리는 역할을 한다. YAML 파일을 사용해 포드, 오브젝트, 배포와 같은 쿠버네티스 리소스를 생성할 수 있다. 

쿠버네티스 오브젝트를 생성할 때는 원하는 오브젝트 상태를 정의하기 위한 사양을 포함해야 한다. 쿠버네티스 API를 사용해 오브젝트를 생성할 수 있다 API에 대한 요청에는 오브젝트 사양이 JSON으로 포함됩니다. 하지만 대부분의 경우 필요한 정보를 kubectl에 YAML 파일로 제공하게 된다. Kubectl은 API 요청 시 이 파일을 YAML로 변환한다.

일단 오브젝트가 생성 및 정의되고 나면, 쿠버네티스는 해당 오브젝트가 항상 존재하도록 한다. 

개발자 또는 시스템 관리자는 YAML 또는 JSON 파일을 사용하여 정의된 상태를 지정하고 쿠버네티스 API에 제출한다. 쿠버네티스는 컨트롤러를 사용하여 새롭게 정의된 상태와 클러스터의 실제 상태 간 차이점을 분석한다.